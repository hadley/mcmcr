---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "tools/README-"
)
```

[![stability-experimental](https://img.shields.io/badge/stability-experimental-orange.svg)](https://github.com/joethorley/stability-badges#experimental)
[![Travis-CI Build Status](https://travis-ci.org/poissonconsulting/mcmcr.svg?branch=master)](https://travis-ci.org/poissonconsulting/mcmcr)
[![AppVeyor Build Status](https://ci.appveyor.com/api/projects/status/github/poissonconsulting/mcmcr?branch=master&svg=true)](https://ci.appveyor.com/project/poissonconsulting/mcmcr)
[![Coverage Status](https://img.shields.io/codecov/c/github/poissonconsulting/mcmcr/master.svg)](https://codecov.io/github/poissonconsulting/mcmcr?branch=master)
[![License: MIT](https://img.shields.io/badge/License-MIT-green.svg)](https://opensource.org/licenses/MIT)

# mcmcr

## Introduction

`mcmcr` is an R package to manipulate Monte Carlo Markov Chain (MCMC) samples.

For the purposes of this discussion, an MCMC sample represents the value of a term from a single iteration of a single chain (of a single analysis).
And while a simple parameter such as an intercept corresponds to a single term, more complex parameters such as an interaction between two factors consist of multiple terms with their own inherent dimensionality - in this case a matrix.
Not surprisingly a set of MCMC samples can be stored in different ways.
The three most common S3 classes store MCMC samples as follows:

- `coda::mcmc` stores the MCMC samples from a single chain as a matrix where each each row represents an iteration and each column represents a variable
- `coda::mcmc.list` stores multiple `mcmc` objects (with identical dimensions) as a list where each object represents a parallel chain
- `rjags::mcarray` stores the samples from multiple parallel chains as an array where the first dimension is variables, the second dimension is the iterations and the third dimension is the chains.

In all threes cases the terms/parameters are represented by a single dimension which means that the dimensionality inherent in the parameters is stored in the labelling of the variables, ie, `"bIntercept", "bInteraction[1,2]", "bInteraction[2,1]", ...`.
The structure of the `mcmc` and `mcmc.list` objects emphasizes the time-series nature of MCMC samples and is optimized for thining.
According to the documentation the `mcarray` preserve the dimensions of the original node array defined in a JAGS model.

The `mcmcr` packages introduces two related S3 classes which preserve the dimensionality of
the parameters:

- `mcmcr::mcmcarray` stores the samples for a single parameter from one or more chains where the first dimension is the chains, the second dimension is iterations and the subsequent dimensions represent the dimensionality of the parameter;
- `mcmcr::mcmcr` stores the samples for multiple uniquely named parameters with the same number of chains and iterations.

The `mcmcr` package also introduces a third S3 class, `mcmcr::mcmcrs`, which stores multiple `mcmcr` objects representing individual analyses.

## Why mcmcr?

The `mcmcarray`, `mcmcr` and `mcmcrs` classes were designed to be easy to manipulate.
As a result, the `mcmcr` package introduces a variety of generic classes to:

- `subset` individual objects by chains, iterations or parameters;
- `collapse` or `split` an object's chains;
- `bind` multiple objects by their parameters, chains, iterations or terms;
- `combine` multiple objects by summing or otherwise combining their values;
- `mcmc_map` over an objects values; 
- assess if an object has `converged` using `rhat` and `esr` (effectively sampling rate);
- and of course `coef`, `coerce`, `print`, `plot` etc said objects.

Finally, the mcmcr package allows the user to readily `derive` an `mcmcr` object of new parameters (with potentially novel dimensionality) from an existing mcmc object by using standard R code to define the relationship between the 'primary' parameters in the existing object and the 'derived' parameters in the created object (and any other values specified by the user).
No more rerunning a model because you forget to include a derived parameter!

## Demonstration

```{r}
library(mcmcr)

mcmcr <- mcmcr:::mcmcr

mcmcr

parameters(mcmcr)
nchains(mcmcr)
niters(mcmcr)
nterms(mcmcr)

coef(mcmcr)
rhat(mcmcr, by = "term")
esr(mcmcr)
converged(mcmcr)
plot(mcmcr[["alpha"]])

mcmcr2 <- derive(mcmcr, "gamma <- sum(alpha) * sigma")
rhat(mcmcr2)
plot(mcmcr2)
```

## Installation

To install the latest version from GitHub
```
# install.packages("devtools")
devtools::install_github("poissonconsulting/mcmcr")
```

## Citation

```{r, comment="", echo=FALSE}
citation(package = "mcmcr")
```

## Contribution

Please report any [issues](https://github.com/poissonconsulting/mcmcr/issues).

[Pull requests](https://github.com/poissonconsulting/mcmcr/pulls) are always welcome.

Please note that this project is released with a [Contributor Code of Conduct](CONDUCT.md). By participating in this project you agree to abide by its terms.

## Inspiration

[coda](https://github.com/cran/coda) and [rjags](https://github.com/cran/rjags)
